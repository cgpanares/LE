import subprocess
import traceback
import argparse
import datetime
import winreg
import yaml
import time
import sys
import os

import win32api
import win32con
import win32gui

from PyQt5 import QtCore, QtWidgets, QtGui
from PyQt5.QtCore import QCoreApplication
from PyQt5.QtWidgets import QMainWindow, QSystemTrayIcon, QMenu, QAction, QMessageBox, QWidget, QPlainTextEdit, \
    QVBoxLayout

# PRE-FUNCTIONS #

parser = argparse.ArgumentParser(description='LE Session Manager commands.', add_help=False)
parser.add_argument('-h', '--help', action='store_true')
parser.add_argument('-v', '--version', action='store_true')
parser.add_argument('-t', '--timer', metavar='<int>',
                    help='Sets the session manager timer (value=integer interpreted as seconds). Maximum is 28800 seconds.',
                    required=('-nomaintenance' in sys.argv or '--nomaintenanceTimer' in sys.argv))
parser.add_argument('-st', '--maintenanceTimer', metavar='<int>', default="900",
                    help='Sets the MAINTENANCE status checking interval (in seconds/integer). Default is 900. Maximum is 3600 seconds.')
parser.add_argument('-nomaintenance', '--nomaintenanceTimer', action='store_true', help=argparse.SUPPRESS)

args = vars(parser.parse_args())

# icons (base64)
image_icon = b"""
iVBORw0KGgoAAAANSUhEUgAAARIAAAEwCAYAAAB7U/4eAAAAAXNSR0IArs4c6QAAK4x0RVh0bXhmaWxlACUzQ214ZmlsZSUyMGhvc3QlM0QlMjJhcHAuZGlhZ3JhbXMubmV0JTIyJTIwbW9kaWZpZWQlM0QlMjIyMDIyLTA2LTI3VDE2JTNBMDElM0E0OS44MTRaJTIyJTIwYWdlbnQlM0QlMjI1LjAlMjAoV2luZG93cyUyME5UJTIwMTAuMCUzQiUyMFdpbjY0JTNCJTIweDY0KSUyMEFwcGxlV2ViS2l0JTJGNTM3LjM2JTIwKEtIVE1MJTJDJTIwbGlrZSUyMEdlY2tvKSUyMENocm9tZSUyRjEwMi4wLjAuMCUyMFNhZmFyaSUyRjUzNy4zNiUyMiUyMGV0YWclM0QlMjJic25tMjlBNjZ0c2ZQQ1h3ZTBjVyUyMiUyMHZlcnNpb24lM0QlMjIyMC4wLjElMjIlM0UlM0NkaWFncmFtJTIwaWQlM0QlMjJEalAwVkNPaVhLZHFGaU1nekgyQSUyMiUyMG5hbWUlM0QlMjJQYWdlLTElMjIlM0U3WjFaZTZvJTJCRThBJTJGVFMlMkYlMkY3d09pRlM3ZDBicmdWclYzS291N1ZoR1hUJTJGOW1Rd0hSSGs5dGhjUDRwRnAlMkZZWjNKSkdOSUppOUNacjR2clB1clVXV3Bhck9YR0tmdVg0VHNTeXdtOFhIMGpzR0JncmdnVVdDc3h5cEYlMkZCazB4MGVOUVk3UjdWalZOcTROemVWeVpvNVhiamhjTGhiYTBIU3glMkZucTkzTGszMDVjejkxbFhmVU83QU0xaGYzWkpPMlBWSEZFcUpyZ3psN1d4TWJMUHpITXNaOTYzTjJaZ00lMkJxcnk1MERDYmtYSWJOZUxrMzYzM3lmMFdaWWRyWmM2SDc1SzdtbkMxdHJDJTJGTlBkbWh2OVhwN3RhdkxuNiUyQkYlMkZydWVtWTJybyUyRjllNlZHcyUyRm16TGJwaGRySG13SllDdWU0WCUyRkhjJTJCSnFOS1d0amJIU0VEbCUyRmtDYktjdk4yQnd2RnloJTJGc0RUTjVSeHRNTU1aNmY1d2FxeVgyNFdhV2M2V2E1U3ZhbnAlMkZPek1kUjBqTnhnYmUwMXl1RU8xdlZsU0IlMkJuaXZvV3RPa3hPbWJNclpCQiUyQnFiJTJGWmZoQlQ5R3N2diUyRnhzajliJTJGRU1xbFVLcDFLOVZMMGxVc1ZVJTJCbFlhcGRLZlJqb2F4Rm5vM3owOFpZeTBxbnFMb3UlMkYxakd0cDR4VVpvUTN5R1hSZnBXc3ZYOW1XVUlibEhOeHZKOWg3JTJGJTJCSnpwS3FObzVvdjNyTzNyOWdvSCUyRlQ0Z2p0TjM1UDF4bzc3cTFnTEhGdXRka2U1ZG9HMlk0Y041T3E0RU90MSUyRmxSRzVQNGU3cnludXRXQ29keVZUNU0wTiUyQmlYRWduMzVYY0JQMHRLdkpZcnhZemk2cmNISlR6alVVNVA3SUczZGc2eHBzTFElMkJzcGFEJTJCNWlyWXA1JTJGZkhXcW1KSkRJZHJ4UkpSUCUyQjBjSG13a3o1Y0NKVkNBJTJGMVhMb3psdHRLZVdOWkdlWW1sSFZ2SXgwcWhtVFhVWGxZZkNza0syczVRNDJVZGZVZG5iNzAzZUdVJTJCU1N4bWs0OEIlMkJ0VFIzNlRUNEZ0Vk9hTVVjeWtMJTJGUWxLS1pOc2xJJTJGclJubXlicFluRnJvaUFWM2RaTmpyV0R4ZjFROUhTVGx5VllYanBNRUFNWFFPZEs2dWdQN3d1V1YwRFJiNjN6SzBZaG5kV1hiNDBaVlJSU0p3Nkc1NVhsckhZbFZyOERGSFYxc3JUZVJXbFN1M3lkJTJCMHJKUW01VzUyVmxvZ2tXYmF1Vm11JTJGdDZJeDdhQ3V1JTJGRkIlMkZWR3M4QjlUSGN0RVNtNlZUbFcwSDByU1lWUFlaT1IlMkJONTRlMWlOMzklMkY2YTZ0aXhtTENDbVYlMkY3dDk0TGZPZWI4JTJCYnBSejlXOGxvNiUyRmJyN0Rob0wyTDRDQnBmckVtMUxTJTJCYjZGdktmdVhTeWExVTA4eXNibUoxV0Myalc5JTJGSjdVOHBzUnVlTmpMTFdpZjdPWnk4ZG96WDJYeXcwcktmRFcwaktxY05DaFBySSUyRnY1M3ZyVVA3bzFhOVhLZmc3YyUyQldNclAya3R1UGslMkJuWkJxZWM4MVZMTHpWUE4xM3FobnV0eTIzcWtiTmtjRnVLUzNadDA2MzIxYlhTN09jeFdKZjdPMG9YemF0OXpvVnJsMXg5aU9ZbHVyMW4xZEgxJTJCN1czUWpDVnFDOFN0cjh2VmFTNVZxa3BvVnBhYmNGWHZkejdiMyUyQnVSbFdseVVYcWRZbkxNUGJaWFFWdFhFRWRza2U4VUU3c09hdmsyT3BVVXRlN3I0YkdxM3ExamNtOWxXdWg5bzElMkZYRUhKYnpxZk9yczBmVXlFJTJGZkxPN3dscW9aNGpuckxTdWdLejE5emFTazdhYzhTRGVONnF6MGV0eWR0MFJIa01XVVdzJTJGUEttT3BmUlpjcjFDUUUlMkJkclNSdTlaYllYbXhtZG5sQ01OVzI4UXlhOE82Qmo1TTZuVHBkVE8zUmglMkJWN2RGbE9tbDZ1a0MxV3VmdDZvV2tuM0VaZ1BkOW1jTFFkYzRSVFFqczFZc2w2TTUyUDlZN0hkT0Y5UEp0VXhVeHQwcnQyd25OeFh6bGRhMjJUMW5LRnpyenBYNiUyRktscmxRVDNra0pqVjJVeDAlMkJzZ1NSNm04amRJOXFrdnNiYkpkYWZ1dTRRWHJvMEhUZm8zNlNKNndVam0yN0l5MEdCN3dnOWcyN1JhQ2R5NjJuSk1NWUdrUzg3UllyV21PZERwZnhmNDRLSXoxOGNXY2dFODRmaTRLaUl3SUFCQXdZTUdEQmd3SUFCQXdZTUdEQmd3SUFCQXdZTUdEQmd3SUFCQXdZTUdEQmd3SUFCQXdZTUdEQmclMkZ6SmJ5aUllNFBxR1IyZFdNVFgwbzI3VFNuTlFReCUyRkgzUHhvaWZ2U0pubG1YRkhnMEllVXFVb0slMkJxeFA5TllkdEUwcHIyRFdjcklZWVNabGd4TVRENlhOQ3hsVVhoa1A4RUdPeFRtJTJCbHpNdjdaUGslMkJvY2F1djZGdkJFY0xIQlNCeFlwNXJRcGo2VzVyY3BsYVhmYWxJZTZyTXBsYVlOcmxuWmhVeDViODFpVjA5S2VMV0ZnMFdiJTJCN2RlSiUyQnJWZ2hQMWwlMkI5VzZ0Q3FYcFYyMFh6YTcxbm94N3R0NkVSWkFtUU9MRUFNJTJGRVJpd0gyWXB6QXpHMG1jbTdUOVV6SWFkN2hCOUNQbVpjR0tDYXBFNXA4SkFzdENuaXI4TUhIelJJY2Iwd1Z2WVZtTHFnSFBRUG8lMkZldXBpYk92NVhXbmNsM2NXbENUbUsxU05ISDhTVXdabkdwRG5OJTJGREJwNW1Cd3B1S0kzVWVEM2tjTzM5c29HSElHRm5IbXNDMlB2YmxzeTJsdmZyYmx0VG1QZFhsczdzSzIzRGJudGkyUHhibHR5Mk54YnR0eTJ0dXo1UXdzMnN5bkxiT1pYMXZHMk5XMmpISCUyRnRzeW0xMW95eG4xYk1rTDkyekdiJTJCclpqalFESUdGamtHZmlOd0lEOWh0JTJCNHByYlZKJTJGYTJjYkI0U1lqajRFY1pGYjFsRVRBV3VuSG0lMkJZZ25ZekdoMG9oVEtXbTE3SmtlVWg5RW5rTXF6MFhseEo2dGIyRFJabTRiZDltOTI3NHY3RDd5eVdQakhzdDNXYm5IOGdOWENvQkZpdm0wN29SZGI5M1BQT0xKdjMwbjFMZDl0MWtBU3dHd0NESHc2JTJGOHlnVjhQTElSc3hNcGtnNWJKM01lWmFVSldSeCUyQkN1Y01qQTZUa3NFcExPdU1QVEVuMzk3UW4yJTJGcWhiZjhpSVNtb3RoUmtLcDI5NE9MZ3p3TUxLbk5hdDlQaUwyejd3dVlmbUg3S21tOXQlMkJ6ZnB3ckxkRmc5ZVBMREFNcCUyRlduTEZyclRuakQwMiUyRjFZNWJMejRudnk5ZGE4MFpCJTJGOGRXREFaJTJCTzkzSmZEZmdZV1c3VVZjSm5WYUp1WDk0c1FrMFM2OXVreEw5WjZXNmhOJTJGWUFxTiUyRiUyQjZWZ1ZzMnQ1NW9CbEQzd0NMRW5MYnRzZmN2U3ZWRFU0ajg5MnYxSHVOWG4yUSUyQlc5UEFJczU4V25PYmZWR21INWhDNUw5JTJGNmVuY2VJSVpQTzBEaXhJRCUyRiUyRjJlQlA0N3NMQ3k2MjBRJTJCTyUyQiUyQlNlOVNLZkJVT3RKSk9wUWZjbGlTSXliSkJwVnVEdngzWU05bU4xb2g4Tjh2MDRWbFgxaTh5N285Rmg4NDdRT0xGTHZXaXdUJTJCdTAlMkI2MXBZejd0dWFqOEIlMkZCeFlBQnY3N25RbjhkMkNoWk5EJTJGZmxjQyUyRngxWWFCbjB2OSUyQlR3SDhIRmxJRzQyZnVUZUMlMkZBd3NsQSUyRiUyRjlyZ1QlMkJPN0RRTXZEZjcwbGZqNSUyQkIlMkJhdkFBc25BZjc4M2ZlSHJ3UHhWWU1GazRMJTJGZmxmNWslMkZEdk1Yd1VXU0FiJTJCJTJCejBKJTJGSGRnWVdVd2Z1Yk9wSGZMUkFyOGdmWEdtUzRPJTJGanV3WURJWSUyRjM1WHVyRHNDNHNIJTJGeDFZVUJtTWY3OGpYV3ZMR1FmJTJGSFZoZ0dmanZkeWJ3MzRHRmtrSCUyRiUyQjEwSiUyQnQlMkJCaFpaQiUyRiUyRnM5Q2ZyZmdZV1V3ZmlaZTlNWHZnNzQ3OENDeWNCJTJGdnl1QiUyRnc0c3ZPeGFLd1QlMkJ1MCUyQkMlMkJhdkF3c3F1dDBIZ3YlMkZzbW1MOEtMSlRzUmk4UyUyQk8lMkJYQ2VhdkFnc3ZBJTJGJTJGOWpnVCUyQk83Q3dNdkRmNzB4ZiUyQkRxd2ZoT3dZREx3MyUyQjlLc0g0VHNQQXk4TiUyRnZTTEIlMkJFN0N3TXZEZjcwemd2d01MSllQeE0zY2xHRDhETExRTXhyJTJGZmsyRDhPN0NRTWhqJTJGZm0lMkY2MG4lMkJIOGUlMkZBZ3NqQWY3OHJnZjhPTExRTSUyRlBkN0V2anZ3RUxLd0glMkIlMkZONEglMkZEaXlVRFB6M3V4TDQ3OEJDeThCJTJGdnllQiUyRnc0c3JPeEclMkZNamJzem9lbXNMa3YwUDhTR0JoWkxmaXY5JTJCZWslMkYzQUZDTCUyRkhlSyUyRkF3c3R1eHIlMkYlMkZjdFoyUTlNb2ZIZklmNDdzSkF5OE4lMkZ2VE9DJTJGQXdzbHU5SCUyRmJpeDBBMzNFUzBKY1FVYVRRUWFmenA1NTVOT0ZSQzRrQmI0OHNJQ3lxMzN4ZjFLdUk1NnUxWWlFZzE4UExLanN4cmlhbTJYNjZSYjM5UFNGTHdUJTJCUGJCZ012RHYlMkZ6cUJmdzhzdkN5SDJZaXh4cGxKNjU2S1dUOG1EOUZIekJ3Sko4WkxMUjU5U0hwYjB0Rm5sMWU2RHFvb0l1NHBhJTJCRXR5JTJCaVBFJTJGRXhuVG1jZ2wwRlRzb2VDYTJMMUpRWTUwMkZ3M3pRa3ZEWER2N1NPbk4wSlRHY2phN0ZvdGMzT05PZ1NCVVlzQXZtc0M2UHhibXN5Mmx4bDlibHRybEwyJTJGS3hPbzk5WGRpZDE4SXVMTTl0WXg3TEM0WnNnUUh6TXA5V3pXWiUyQnJScGpWMW8xUm0lMkIwYXFlY0slMkIyYXphJTJCMGE0VDd0Mm8yRFlSVWdRRURQeElZc0NleE56d3VvWXFwb1I5MWNTbUxnb3ZHcDNncmNWdXFVSE1vajF1S2c3JTJCV0pSbDkxc2JvcllIJTJCamt1TDA4ODBTZG1XTU5QSk5sdk9FcE5sRTl0aTdaQnNudGpOSTVhYjNSbyUyQk96YzdXcUpaR2lZZHpOREk5VyUyRm85U2VySnhaQXFRT0xFTHV3S2FlbGVlekphMmNlZSUyRkxZaEhuVnlwd1c1Ykd5RzBmMFdKVFR5bHdXNWJHeXdFa2NXS1NZZjh0RjZMVjI2OFN2dFZ3bjZ0TjJFZWJYZHRuczlqRjlXeSUyRkMlMkZGb3Z4cDR0WTJEUlp1QW5BZ1AybzJ4VnJKQXkyY3lTTWprMVVKbGs3TVlZbXQybWZsREVjcTR5UVY4eSUyQjJ6eHhLcVVaUnVVY2Q5bE41N3ElMkIxMnp6UUluWjJDUlluNWxrckFiNWRsbFJ4N2IlMkJyWWR1ZG5WTWJHMzZvTm55eFJZdE5tTiUyQnY1NmVmWnJvOG9QYnFNWXU5RmVYcThQQWlobllCRmk0UDhCQSUyRlp3VmxkUm1aektRMXdtUzJtaGFqT3AxWkR3RSUyQkkycDclMkJqRDc0cTh5YzI3JTJCRTM5SmVZS3duckpaYiUyQlFOYVFIcmh5JTJCdFdFam1Cbm91RTlaa3RoNXFCZGUlMkZ0WjNONWVvMGM2NWN5TGRzNlk1dlF1Y3ZpR3pGdFN1eUZoJTJCcDdUT3pZVEp6TDFBJTJGZEhjaiUyQlZJYnBIbXdWUUI4Q2l3NXcyNXJFN2w0MDU3Yzdmd3J5MjU3RXhqJTJCVjU3ZXZDOGk3dDY4THluRGJtc1R1M2pUbnRMb0E2QUJZaDV0TzIyY3l2YldQc1JzdkdjdnhiTnB0ZWJkZk9PVmZiTlpMajE2N1p6TGRkWXl4dzhnY1dLUWIlMkJKREJndjhkZyUyRnZqZkprUHU0cEhROFRSUG8yU2xVNnJxeW9FWjVNQ0N5V0FHJTJCViUyQm5DeXYzc1glMkJZUXc0c29BeGlSUDE5dXQ3U3N4eUlFd1VzcUF6OCUyRkw5TjRPY0RDeW03NWVmTFhZT1dhbUw3S1ZYTG5tbkVrNFFFTXBUbyUyRiUyRnBDd1RZdUpJNkNKNmZZb0JHMWN6aWk5b2hGMUdZc2NDVUJXSlRZTFMlMkZmYmVrZSUyQjQ5NDhyRnl0JTJGMTc3ZHhsJTJCOEVyQjhBaXhHNTUlMkJMNnRQS1BQTjd2bnB1c3RQTXZ4YmVFSkMyQXBBQlloQnY3OVh5WHc3NEdGbSUyQlg2T0xnV0xwVVdMWlhsTTVXS2lvcGpaeld6UWh0OWNJYkVLemJiSlpONEI3R0d5amxiUVNscmJlayUyRkxDOUk2ZDRWb0lUOWpxMnZYS1ZZbDdQNm1VUCUyRlBMREFNcGNOZXl6YlpjTk91MzY1dEY5ZjJ3NU91bmVOTjdjRlgxZzI5TDBEQ3liemJadHQ2dGMyTTNhcmJYYm1CU2ZkdFM3anRiYjV6R0gwRExDZ012Qzd3ZThHOWklMkJ4MHA3R0tCdmlHR1VMR3JlTXNmMnVTNng5bUNjaHJPVzBYblpRaThVOU85QzRaeUtPaGNiWU5MNmVvbzlFN1MyQiUyQjk1YTQyM3JURjlZbUd4c0h5Uk1OckVjUlpFOGVkOU1YNnhlZkQyT1NBQjFCQ3hDekcyRExydjBXS0RiTGwwVzZMVEtDd3YwMktXUDdmblk1WGZTaGZWZFdPV3RpRHFCMHhDd1NER2ZscEV5JTJGM2FSVWI5MmtUSCUyRmRwSFJtMjNpS2UlMkJiNlZxcnlQaXQ1MnJQMWdhd2FEUHdWOEZmQlJZZ2RpT3VYR2xFNHhmMGNFeURPWXRwUU5sJTJCJTJCazZzOGlNJTJGeExaYWFIVExEanJJayUyRjZsd241QTZLYmpwSDBjdVlDc2Y3VFN5YXBJbjEzSnhhVkZoNEFQM2lLYnFZUFltYWF6R2gwSklpekklMkJKQnFnb3dQWWZUR3VvZkJrenl3U0xHcmtVWGRsdVd5Tm85ZGVhek5iVmR1YTd1d0tvJTJCMXVhM0tZMnNlcTNMYTJxMlZEcDh0WVdEUlpyZmlqUHEwWVpUNXQyQTI5VzNCR0wzV2ZqRiUyQllWVWVXJTJGTnZ3Umk5dXNiaHMyVU1MT0lNJTJGRVZnd0g2QjNWaTM3RFp0MkhTSzZjcExyNTVmSzFSSXY4dG9RcXd3M2lOV3lHZ3plOFJ4NnpoRDVIV3BxRlM3RGpiRnJNUlk2OHh3JTJGdzQlMkJTMm1mSkdjWmFrZkZacyUyQldMckJvczdzc3lrMHZMTXBwWnpmTzc3RW90NTE1YmNwbFo2MnJkdWF5S1plZEJWRG13Q0xFJTJGcWJsT2xIJTJGbG92UUclMkJmM2I3a1k5VzI1akNzdGw4MzhXaTZiQlU3aXdDTEZ3RDhFQmd3WU1HREFnQUVEQmd3WU1HREFnQUVEQmd3WU1HREFnQUVEQmd3WU1HREFnQUVEQmd3WU1HREFnQUg3bDFnS1h2Q0NGN3pnQlM5NHdRdGU4QXJtYTRuZjZ2aXRTTDZuVXhrN0szMTFweUQ1MnNDQUFRTUdEQmd3WU1DQWVlYmU3MHNiSEttNjBoemc2TlZjVWVEUWg1U3BTamhrZkgyaXQ5eTBSU2xaaDZrWTR4WEVUTXdxNHdIZTRWaWM0M040bzlvSDRiN0R6SnhSRXBpbWpybjUwYnF1SjhXcEolMkJHc3AlMkZwazBIYm82VkRhdkpDQWtLN281d0c1NjlBeWc3RTBZVUolMkJKaWpTJTJGa1BGVEZBdEVnTlFHTmlSQWJGV1l1cUFLRzdkbFhCTTlqNlAzbkJNaXBnMElWdGJQY21TckE4VDd6S0lEWEF3UVlodiUyQjBoR05YVklJV1pyYXRqcERoMmFVckVpQmc1ZExUckV5TTY2TW5YZTFoVlJrekk0YXlzbXpmSCUyQkVNbnhzU3pWSjlaRzRySVlDNTNFMFN3Sk9JN21kMWROJTJCR2FLbCUyQklrbW1kR3E1Rm9uckIlMkI3aU5yVnhxSEo3MnVuUFdkenFnNGVPclRGWCUyRld1YkdZR0NlZHc1cU1qMkVOYWtjNUpGTXBhYSUyQkpxUW5aZTlkSnVYY2R6aSUyQlRKc2o0R2dSejc3Y3VaeUJrRjJLRzlZM2FUaUpUcG0zQjNOMjlYdFZkNnlsJTJGZVRTbWExUU9WUXFnbG44Z2M2OUlKT3ozYkIxYzlWNmwzNlBucjFjQVAxJTJCQkxoT0xkJTJGa2dnWkJjaUpseiUyRmFrTFNkJTJCVEhsNiUyRnMydGc1ZERqZ3dSQ2RtRm1UaHR5UyUyRnF1OU9ENm5kJTJCekZkUHMlMkJyMUJ0WjNyQjBkeW9XVnVDd3BPJTJGWDdTdHQ2bDlUdlI5Z2pxOTMlMkI4ZnFmYVpqWiUyRjBuY0Q2dmNITU5jYWsxQyUyRlI0S0Z4MyUyQkglMkZwa28xTzllJTJGeDM2WiUyRjU5JTJGOTJ6NGpIMHowVENmM2V2YnczMU85VHZnWkJkaUZsQSUyRlhkdm5RUDElMkIwUHJkNmNGQmFsJTJCaCUyRjZabjJNT0N3cFklMkZRNzlNeiUyRkluRDVTa092MzlmblhSa0FrRjFvVzFQb2RucSUyQkMlMkZ3NyUyQk8lMkZqdndaQmNlQm4wdjBlUVFmMGVUZWJxZjNmOVVyb3JRZjk3ZUppbiUyRjkzN0xQdlBFJTJGUyUyRmg0YzU2M2ZubkFjMjklMkJYcHlUa0hCJTJCcjRuJTJGUGhBemJYeVRNREIlMkJyNUJ6TDNqTUdZT1JJVWFkMGpNeFI1cVVWbUhPcHRNbXUwaFJsZUFKMFQ4ZDQ0UjZtTFZFY3RUc0VGaFRjVk1uZHgwSkxJVVhEbDNvJTJGSmc2ZmY1YiUyRkcyUHhPUEVmWDFoYVM4OUNoclM2dmROMjZVa1RyckNsT3loNXRUYUhQRGxaYjY2d3RWQTdJZk5KbjMlMkJjJTJGeHB6ejdNdmpGcGI4SVQ3Rlc0aXZaVWxHbjdVeGVtdWd2JTJCTnl5JTJCbUltb1Fla2szTU5sdk91dGp5d00yT2xtaVdodGg3ZWt2VGVmWUd6TFAlMkZQbU9hT2tlMFlMcmFsdkEyYm0xWkRtMk5rNDJUdHBKbHMzeTVKZE5XdWRtdG5iUzFwREV0QW5IbklXWnZ6U3pSMWRSQU1uWDNVdTAyOVlNaWxuT1ZDZnFTYldTTG1IR1lWYTh6cDA4c3Jvb1Z3WEdPSU54dm1CblJFWk9wUzg1TVI1bjluJTJCbUlNWmNQNnlvSEFibmYwTEtwUENUeGR0SUNsaWxmbFhsZGFqVWs3R0hNZSUyRmdOJTJGU1htU2dKNUdPbk9STU44dGhSbW1HcVVkcEdlMHRpMW1CZnQ3Y2NvUjJvM0pFemZjM29IbjYweVJOcWF5QldvQ2IlMkZQbUxZT2RmVjQwbGFiMDk4ZHV2cXd0V0pycTE5TjZFNXR6ZUpPYlNIWXMzT1l4dmlHekZzbmplMlBVQzklMkJud1g0dDNpYXA3MiUyQjZaUUtUOVVlejl6JTJCU3ZCaWo1eTBic2hkJTJGYVIxNkgxOUNQUDB2cVpVTFVzbEhZaSUyQlYzMmhZSTBMaVNPTWtQdmhHcDlxSE5XMUFhanhtYjRsVkNDSEVrVXdqJTJGR0JETm1SUldWS3VsWU5pVmVrb3FMaXZyaGRNb216eEJxUyUyRmRkUHh1NU1GOCUyRmhKTkdPZDZUTFdhamJIODJvZnBITmtNNVlwdUZtVm1oN05KeTF0bzlXOWVVelZxWmhZYiUyQkQwUktQWnlUR0tZdFFLNmQxclBmOXJvdjFMbHFzMyUyQjlBJTJCdjBTdGJjRWJ1bGI0eTB1RFpLaXNCcVdQR3JSdjlUcnhRZ0lWeDlLUUtRUld1YU9NV3hyY0pnbmoxR1lCZyUyRmk3R2lkTlRpTnI2Y2VEWklITUYlMkJQbExrWTElMkJEeUNBSWhqeEF6VjElMkZnblBWbGpVanZ5SDc2VHZUNmtSOWl2UmIyQTJLdm13NnBweiUyQjdKTmhxSCUyRmVONEU0UEhKV1Z4ZFhGWHcxaFFUeTFhaUx1ZlpJYWlQc09NM1AyRFROZEhYb3FZcmFtR2wySHBzUkJmdVBTVkd5bHg2aEJNVjNGMUVITTFoWCUyQk9hMlJYMWZPSjZsQnVmUFFzb3ZuWmM3bm5XOE5tMDcxaXg3NWZieEh0S2dWS2xpTHpld1I5MUp5aHNqclVrbXA0cDdMWm9zdzNMcVN1amt3ZHgxaWRrVlRKMG8wdGFMVXRUJTJGVGt6eWFsRTk2S3JyMHhFMFJzJTJGV0UydERBM0RNd1lNQ0FBUU1HREJnd1lJenRmbmE1VjNqQjYxR3ZOJTJGeVd4VzlwZzRCNnlyRHpTdGQyeWdUSTFvQUJBd1lzRXF5dGtpZUN0SGR0TE9PJTJCdFdOeHhTbmk0VTNGdmRDVjhhSiUyQmhSMldvNk5sNzF0cUNKRWNYMGw2SjgyaSUyQkNjcmlaSzFLQ1dmdFNqTklsbUpOS3ByaHBLMUIwdjFLcGFNWiUyQjNCUVV3bkt3eTZWNGxrS3d5eU5TTFpDb05Tc1U1R0xrVDFLUmVSWXJWQmVycTFlVko3SVdOcGt1WnBRSTJaVk5ib0kxbXpYbW1lZ0w2bXNaUk5ERWllZHNRRlVaaFpnb1dPcFhhSlBLTTVqZzVIbHBBYVRaVThUZjJkV2VaazdVVDduRkVkODBKV3VLczFpQXdldmI2ZGI3SlhNMlBuaktyY1V3NjU2dyUyQk9tJTJCTXY5NzFIN3BHc1oyakVvdWZJM1l5dzNHbjl6bVR3TzNKbmtXb1VKdmNvdDZ1JTJGV3Q1QjdpOVBxV2RBN3MlMkJSdTdkZGphZyUyRjglMkZ2MXpBSGslMkZwUjI5ZUNxWjZJcGQ2aG5Jdk83NmRTdXFoRnVWNThwOXlqN004JTJGc0o0ajI3OVduMSUyQiUyQlJsRHUwcXlEM29Nams5MzgzZGVGMzA2JTJGS25ma1d2eXAzJTJCTjJFbjdsVmYlMkZVNW54QSUyRm5UT2ljcWZsdlZ3bnNiJTJGVTJKRTlyN1klMkIyVFBwejFkbGdUNWVOVDFCY3haTDlLWTdjakRERDY0RmRTTllVb1VlS2FwZU9ZbTNXMUJNRmluWEdXJTJGM25iUElBSlRMMk1nc2g4VkdacEYxSlprZTVkbDM5Q3hHUnZTczZZZ2NGZ25YanFFcSUyQmNSUWxWd3hWR25FVzdhM0hmRTJTSGYzRzR6TWoyWXpOa3Q3TEI1TUt3YUpuMGpwYVI1bkhVdDd5bWlHem9YdjZZNHhhYWU1dVVHNncxJTJCVElvdHU2WW9TVyUyRm5EYUtOczM2aEdoTVd4SlVXeFF1SWVlMkpMOWlaYloyUkp6Uk0lMkY4aFFIbEVhUVJNZkFOaDdoQ0pJNmFsbkkyTG8lMkJqcnFQUlNRZVpkYUdsTEdCa3dCQzRvQUdrbkhsa09xem91TUR4bFlhYVY4S1NwVzFMMUdVNTFQOFRSb2JVNnJUaUxZUjlUaXA1SmtNZmlsMm9SMmp6cFo4UkwxVDR1dG5haXF1RFQ3eWl6NFJUbHJXV1ZDcEhmYVd2djdCJTJCclcwUGI5b0l5cHRHc2xONU10VlBGcmZKNUxiQ0V0SiUyRjU2d3NRZkhvclJGdmVkbTZGalJna1ZWSTlHM3BGR25pbiUyQnAlMkJzVGV3ajllZFolMkZJaWVlJTJCTUZLQ21kOFhxTHY5dGQ5Z00lMkJxJTJGMmxaTSUyRkRra3RpcjV4ZlhPWjN0TWpxc2tybFpxQnd0JTJGSkdzV0ZtczhIWXVqdXQ3dVlZbG1QZUQ2SGVhT0tkYW5NYWxZVExGVFJLcjBlSTU3VlY3Y01hbWtacFBWcDhHN3gxOHJqZjRSaUZqRU50dkRZTEdpam04bXJYa2Q4WWJpWlJYJTJGRW9scXZDRXl6NHhadEQxWGpNUk1tOG9WcjZjZ3J1bDhxbXJ6U0hwYWVodXlMazBsU2ZjTjNMMEJBd1lNV0FRWXhDR0o5aXREUW5tUXR6b0J1VlRSemt0ZjNTc1laUmNZc01jdzlsdmc2bnolMkZOcUV4WGhFUHBjMEwlMkJXRWZscm45WkJiNSUyRm9PczJ5cW9GdW13WDNUSWpaSE9mekliM3pYdiUyRmhSZE9vQjM0MkswRiUyQkJCcTFVWmk0bEI1QldHZVBZakdxdjk2OW5Vbmg0cDc1Z2lYQmlTUTglMkZxV29HN1d6ZWp2ZjZpZmRVMzBzVmFGSjdFeGdlS1JpRWNFWjVwZVdkWGZUUDl3ZGd4TmlJdEhDdnJzTFVKOUM5SGpmNUJlWmRPNVQwY1R4TiUyQm9yeUhZNldIQjVkM3N0WkZPT3IzUjVaM01XVDFPNTBYOFpEeVR1ZjNuTmFQQyUyQkM5dXN2NzRwSGxuWllkMnYlMkY2N0R1RDhnNzElMkI5WDZuWTlzJTJGZjZvMFVMblZWdERVdWJwNk9aMWolMkZ3cTVhVVclMkZpRXFLUXBaN3FyRktmam5uSHNNYzFDdSUyQnl0MmZwb1luJTJCTHZ2bU9NR1NzMzZicGVoaGFDVmVQWjZraXVjYXRWbjNHcnJHU0haWXlxYzczeTglMkJyeTNwWEpQZU5IUTdKbXZIdGw1JTJCJTJGV01xNVZtQU40dDc3MTYwUEdCUHF0Unh1NE8lMkZiV3I2NjFQOW5xcnZja3gyaXdzUGdUbnRVVDJmcVhQbU8xUE1tMUNtSUE3OHV2SHZhTSUyRnZHdVNNZldEdlN1UEJlNHUlMkZFdyUyRnpYY3lKYWUxZHFjSzM0OSUyQjZxQkFYc2slMkI5a0h2Zzk5TGZGYkRyOWx5UGMwJTJCenhodjFlUVpHMnpJYTU1UE5IUWg1ZHJSMzc3dkhZODU2UjJkTVZzUHNWbWZ2RDl0YWJkenNzZk5QaHN1MGZMbFV2ayUyQmE4OUQwNHFJSyUyRjYwWkptWTlodnA5Tkk5MmZKblh1bTNQRlclMkY1YmNtNXp5VHM2UVhudG1sN2R5Sk9kbmZKYUxXYkElMkZVbmV3T1hzSFVYZk15M1BNdm51b0pPdVRSWXZxS212NWRyU1MwanY0aWRKTHh4YWZaZ1ljTjJ1Y3lhZUxqeSUyQnRweEhNNlNOaG04blJza2NtUDd0TjhtRSUyRk0xcnZSY2klMkJDRWpEc1pjWVoybHJVOXRqRW92eEZLMzZhMjFoT3BDUWV4RXk4MzFCVzg0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
"""

refresh_icon = b"""
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
"""


def wndproc(hwnd, msg, wparam, lparam):
    """
        lparam events:
        - 2147483648 (Logoff)
        - 0 (shutdown/reboot)
        - 1073741824 (forced shut down)
        - 1 (graceful exit) this is excluded.
    """
    print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - WinEvent lparam: " + str(
        lparam), flush=True)
    if str(lparam) != "1":
        logged_user = os.getenv('username')
        log_message = "User '" + str(logged_user) + "' has been logged off."
        print(
            datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + log_message,
            flush=True)
        if checkEventSource(event_log_name, event_log_source) == "True":
            addEvent(event_log_name, event_log_source, "110", log_message)
        else:
            createEventLog(event_log_name, event_log_source)
            addEvent(event_log_name, event_log_source, "110", log_message)
        sys.stdout.close()
        try:
            os.remove("config.yaml")
        except OSError as e:
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[WARNING] - " + str(e),
                  flush=True)


def wndproc_func():
    win_mdl_hInst = win32api.GetModuleHandle(None)
    wndclass = win32gui.WNDCLASS()
    wndclass.hInstance = win_mdl_hInst
    wndclass.lpszClassName = "SessionManagerClass"
    messageMap = {win32con.WM_QUERYENDSESSION: wndproc,
                  win32con.WM_ENDSESSION: wndproc,
                  win32con.WM_QUIT: wndproc,
                  win32con.WM_DESTROY: wndproc,
                  win32con.WM_CLOSE: wndproc}
    wndclass.lpfnWndProc = messageMap

    try:
        print(
            datetime.datetime.now().astimezone().strftime(
                "%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - Start monitoring windows logoff/shutdown/restart events",
            flush=True)
        sm_WindClass = win32gui.RegisterClass(wndclass)
        hwnd = win32gui.CreateWindowEx(win32con.WS_EX_LEFT, sm_WindClass, "SessionManagerWindow", 0, 0, 0,
                                       win32con.CW_USEDEFAULT, win32con.CW_USEDEFAULT, 0, 0, win_mdl_hInst, None)
    except Exception as e:
        var = traceback.format_exc()
        print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(var),
              flush=True)
        print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(e),
              flush=True)

def secs_to_minsec(secs: int):
    mins = secs // 60
    secs = secs % 60
    minsec = f'{mins:02}:{secs:02}'
    return minsec


def addEvent(event_log, event_source, event_id, event_message):

    try:
        with subprocess.Popen(["start", "/B", "/wait", "powershell", "Write-EventLog", "-LogName", "\"" + event_log + "\"",
                           "-Source", "\"" + event_source + "\"", "-EntryType", "Information", "-EventId", "\"" + event_id + "\"", "-Message",
                           "\"" + event_message + "\""], stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                          shell=True) as p:
            for line in p.stdout:
                print(line.rstrip().decode("utf-8"), flush=True)
            temp_err = p.stderr.read().rstrip().decode("utf-8")
            if temp_err != "":
                print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + temp_err, flush=True)
    except Exception as e:
        var = traceback.format_exc()
        print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(var),
              flush=True)
        print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(e),
              flush=True)


def createEventLog(event_log, event_source):

    try:
        with subprocess.Popen(["start", "/B", "/wait", "powershell", "New-EventLog", "-LogName", "\"" + event_log + "\"",
                           "-Source", "\"" + event_source + "\""], stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                          shell=True) as p:
            for line in p.stdout:
                print(line.rstrip().decode("utf-8"), flush=True)
            temp_err = p.stderr.read().rstrip().decode("utf-8")
            if temp_err != "":
                print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + temp_err, flush=True)
    except Exception as e:
        var = traceback.format_exc()
        print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(var),
              flush=True)
        print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(e),
              flush=True)


def checkEventSource(event_log, event_source):
    i = 0
    while True:
        try:
            key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\CurrentControlSet\Services\EventLog\\" + event_log)
            assert key != None, "Key = None"
            KeyName = winreg.EnumKey(key, i)
            if KeyName == event_source:
                return "True"
            i += 1
        except Exception as e:
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(e),
                  flush=True)
            print(datetime.datetime.now().astimezone().strftime(
                "%m-%d-%Y %H:%M:%S [%z]") + "[WARNING] - " + "Cannot find the event log or source.", flush=True)
            return "Cannot find the event log or source"


def iconFromBase64(base64):
    pixmap = QtGui.QPixmap()
    pixmap.loadFromData(QtCore.QByteArray.fromBase64(base64))
    icon = QtGui.QIcon(pixmap)
    return icon

# MAIN #

event_log_name = "<event_name>"
event_log_source = "LE Session Manager"
timestr = time.strftime("%Y%m%d-%H%M%S")
timestrlogs = time.strftime("%A, %d %B %Y %I:%M%p %Z")
filename_log = timestr + "-attempt"
TIMER_DURATION_INT = 0
CURRENT_TIMER_DURATION_INT = 0
MAINTENANCE_TIMER_DURATION_INT = 0
CURRENT_MAINTENANCE_TIMER_DURATION_INT = 0
CONTINUE_TIMER = None

def pre_start():
    global TIMER_DURATION_INT
    global CURRENT_TIMER_DURATION_INT
    global MAINTENANCE_TIMER_DURATION_INT
    global CURRENT_MAINTENANCE_TIMER_DURATION_INT
    global CONTINUE_TIMER


    try:
        os.mkdir("logs")
    except OSError:
        list_of_files = os.listdir('logs')
        full_path = ["logs/{0}".format(x) for x in list_of_files]
        if len(list_of_files) == 10:
            oldest_file = min(full_path, key=os.path.getctime)
            os.remove(oldest_file)
    sys.stdout = open("logs/" + filename_log + ".log", "w")
    print("LE Session Manager - " + timestrlogs, flush=True)

    wndproc_func()

    try:
        if args["timer"] and not args["nomaintenanceTimer"]:
            log_message = "[-t/--timer] is set. Overwriting the config file (if exists) and to use values from the arguments given and continue..."
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + log_message,
                  flush=True)

            if (int(args["timer"]) <= 28800) and (int(args["maintenanceTimer"]) <= 3600):
                try:
                    os.remove("config.yaml")
                except OSError as e:
                    print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[WARNING] - " + str(e),
                          flush=True)

                TIMER_DURATION_INT = int(args["timer"])
                MAINTENANCE_TIMER_DURATION_INT = int(args["maintenanceTimer"])

                print(datetime.datetime.now().astimezone().strftime(
                    "%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + "Timer new duration value: " + str(
                    secs_to_minsec(TIMER_DURATION_INT)) + " (minutes:seconds)",
                      flush=True)
                print(datetime.datetime.now().astimezone().strftime(
                    "%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + "MAINTENANCE interval new timer duration value: " + str(
                    secs_to_minsec(MAINTENANCE_TIMER_DURATION_INT)) + " (minutes:seconds)", flush=True)

                if checkEventSource(event_log_name, event_log_source) == "True":
                    addEvent(event_log_name, event_log_source, "110", "Timer new duration value: " + str(
                        secs_to_minsec(TIMER_DURATION_INT)) + " (minutes:seconds)")
                    addEvent(event_log_name, event_log_source, "110", "MAINTENANCE interval new timer duration value: " + str(
                        secs_to_minsec(MAINTENANCE_TIMER_DURATION_INT)) + " (minutes:seconds)")
                else:
                    createEventLog(event_log_name, event_log_source)
                    addEvent(event_log_name, event_log_source, "110", "Timer new duration value: " + str(
                        secs_to_minsec(TIMER_DURATION_INT)) + " (minutes:seconds)")
                    addEvent(event_log_name, event_log_source, "110", "MAINTENANCE interval new timer duration value: " + str(
                        secs_to_minsec(MAINTENANCE_TIMER_DURATION_INT)) + " (minutes:seconds)")

                if checkEventSource(event_log_name, event_log_source) == "True":
                    addEvent(event_log_name, event_log_source, "111", "LE Session Manager has been started.")
                else:
                    createEventLog(event_log_name, event_log_source)
                    addEvent(event_log_name, event_log_source, "111", "LE Session Manager has been started.")
            else:
                raise Exception(
                    "Logoff timer should be not more than 8 hours (28800 seconds) and MAINTENANCE timer should be not more than 1 hour (3600 seconds). Please try again.")

        elif args["timer"] and args["nomaintenanceTimer"]:
            log_message = "[-nomaintenance/--nomaintenanceTimer] is set. Disabling MAINTENANCE checking..."
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + log_message,
                  flush=True)
            if int(args["timer"]) <= 28800:
                TIMER_DURATION_INT = int(args["timer"])
                MAINTENANCE_TIMER_DURATION_INT = 0

                print(datetime.datetime.now().astimezone().strftime(
                    "%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + "Timer new duration value: " + str(
                    secs_to_minsec(TIMER_DURATION_INT)) + " (minutes:seconds)",
                      flush=True)
                print(datetime.datetime.now().astimezone().strftime(
                    "%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + "MAINTENANCE interval new timer duration value: N/A", flush=True)
            else:
                raise Exception("Timer should not be more than 8 hours (28800 seconds). Please try again.")
        else:
            config_file = open("config.yaml")
            data = yaml.safe_load(config_file)

            log_message = "[--timer] or [-t] is not set. Loading existing timer and maintenanceTimer last state from config..."
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + log_message,
                  flush=True)

            if (int(data["originalTimer"]) <= 28800) and (int(data["currentTimer"]) <= 28800) and (int(data["originalmaintenanceTimer"]) <= 3600) and (int(data["currentmaintenanceTimer"]) <= 3600):
                TIMER_DURATION_INT = int(data["originalTimer"])
                MAINTENANCE_TIMER_DURATION_INT = int(data["originalmaintenanceTimer"])
                CURRENT_TIMER_DURATION_INT = int(data["currentTimer"])
                CURRENT_MAINTENANCE_TIMER_DURATION_INT = int(data["currentmaintenanceTimer"])
                CONTINUE_TIMER = True

                print(datetime.datetime.now().astimezone().strftime(
                    "%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + "Timer duration value left: " + str(
                    secs_to_minsec(CURRENT_TIMER_DURATION_INT)) + " (minutes:seconds)", flush=True)
                print(datetime.datetime.now().astimezone().strftime(
                    "%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + "MAINTENANCE interval timer duration value left: " + str(
                    secs_to_minsec(CURRENT_MAINTENANCE_TIMER_DURATION_INT)) + " (minutes:seconds)", flush=True)

                if checkEventSource(event_log_name, event_log_source) == "True":
                    addEvent(event_log_name, event_log_source, "110", "Timer duration value left: " + str(
                        secs_to_minsec(CURRENT_TIMER_DURATION_INT)) + " (minutes:seconds)")
                    addEvent(event_log_name, event_log_source, "110", "MAINTENANCE interval timer duration value left: " + str(
                        secs_to_minsec(CURRENT_MAINTENANCE_TIMER_DURATION_INT)) + " (minutes:seconds)")
                else:
                    createEventLog(event_log_name, event_log_source)
                    addEvent(event_log_name, event_log_source, "110", "Timer duration value left: " + str(
                        secs_to_minsec(CURRENT_TIMER_DURATION_INT)) + " (minutes:seconds)")
                    addEvent(event_log_name, event_log_source, "110", "MAINTENANCE interval timer duration value left: " + str(
                        secs_to_minsec(CURRENT_MAINTENANCE_TIMER_DURATION_INT)) + " (minutes:seconds)")

                if checkEventSource(event_log_name, event_log_source) == "True":
                    addEvent(event_log_name, event_log_source, "112", "LE Session Manager has been resumed.")
                else:
                    createEventLog(event_log_name, event_log_source)
                    addEvent(event_log_name, event_log_source, "112", "LE Session Manager has been resumed.")
            else:
                raise Exception(
                    "Logoff timer should be not more than 8 hours (28800 seconds) and MAINTENANCE timer should be not more than 1 hour (3600 seconds). Please try again.")

    except Exception as e:
        var = traceback.format_exc()
        print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(var), flush=True)
        print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(e), flush=True)
        if checkEventSource(event_log_name, event_log_source) == "True":
            addEvent(event_log_name, event_log_source, "113", str(e))
        else:
            createEventLog(event_log_name, event_log_source)
            addEvent(event_log_name, event_log_source, "113", str(e))
        sys.stdout.close()
        file = os.getcwd() + "\\logs\\" + filename_log + ".log"
        subprocess.Popen(["notepad.exe", file])
        sys.exit(1)


class App(QtWidgets.QMainWindow):

    def __init__(self):
        super().__init__()

        self.timestr = time.strftime("%Y%m%d-%H%M%S")
        self.timestrlogs = time.strftime("%A, %d %B %Y %I:%M%p %Z")
        self.filename_log = self.timestr + "-attempt"

        if CONTINUE_TIMER:
            self.time_left_int = CURRENT_TIMER_DURATION_INT  # setting the duration of the timer
            self.maintenanceTimerInterval = CURRENT_MAINTENANCE_TIMER_DURATION_INT
        else:
            self.time_left_int = TIMER_DURATION_INT  # setting the duration of the timer
            self.maintenanceTimerInterval = MAINTENANCE_TIMER_DURATION_INT
        self.appTimer = QtCore.QTimer(self)  # setting the QTimer module in a variable
        self.maintenanceTimer = QtCore.QTimer(self)
        self.backupTimer = QtCore.QTimer(self)
        self.winEventTimer = QtCore.QTimer(self)

        # App window
        self.win = QMainWindow()
        self.win.setFixedSize(352, 206)
        self.win.setWindowTitle("LE Session Manager")
        self.win.setWindowFlags(QtCore.Qt.WindowCloseButtonHint)
        self.win.setWindowFlag(QtCore.Qt.WindowCloseButtonHint, False)
        self.win.closeEvent = self.closeEvent

        self.icon = iconFromBase64(image_icon)
        self.win.setWindowIcon(self.icon)

        # Widgets

        # MAINTENANCE status
        self.maintenanceStatus_lbl = QtWidgets.QLabel(self.win)
        self.maintenanceStatus_lbl.setGeometry(QtCore.QRect(60, 10, 231, 20))
        self.maintenanceStatus_lbl.setText("Initializing...")
        font = QtGui.QFont()
        font.setPointSize(10)
        self.maintenanceStatus_lbl.setFont(font)
        self.maintenanceStatus_lbl.setAlignment(QtCore.Qt.AlignCenter)
        self.maintenanceStatus_lbl.setObjectName("maintenanceStatus_lbl")

        # time to check status
        self.ttcStatus_lbl = QtWidgets.QLabel(self.win)
        self.ttcStatus_lbl.setGeometry(QtCore.QRect(60, 30, 231, 20))
        self.ttcStatus_lbl.setText("None")
        font = QtGui.QFont()
        font.setPointSize(10)
        self.ttcStatus_lbl.setFont(font)
        self.ttcStatus_lbl.setAlignment(QtCore.Qt.AlignCenter)
        self.ttcStatus_lbl.setObjectName("ttcStatus_lbl")

        # timer label
        self.timer_lbl = QtWidgets.QLabel(self.win)
        self.timer_lbl.setGeometry(QtCore.QRect(70, 50, 211, 31))
        font = QtGui.QFont()
        font.setPointSize(16)
        font.setBold(True)
        font.setWeight(75)
        self.timer_lbl.setFont(font)
        self.timer_lbl.setAlignment(QtCore.Qt.AlignCenter)
        self.timer_lbl.setObjectName("timer_lbl")
        self.timer_lbl.setText("Logoff Timer:")

        # current timer and frame
        self.timer_frame = QtWidgets.QFrame(self.win)
        self.timer_frame.setGeometry(QtCore.QRect(70, 90, 211, 61))
        self.timer_frame.setAutoFillBackground(True)
        self.timer_frame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.timer_frame.setFrameShadow(QtWidgets.QFrame.Plain)
        self.timer_frame.setObjectName("timer_frame")
        self.timerLabel = QtWidgets.QLabel(self.timer_frame)
        self.timerLabel.setGeometry(QtCore.QRect(50, 20, 111, 21))
        font = QtGui.QFont()
        font.setPointSize(18)
        font.setBold(True)
        font.setWeight(75)
        self.timerLabel.setFont(font)
        self.timerLabel.setMidLineWidth(0)
        self.timerLabel.setAlignment(QtCore.Qt.AlignCenter)
        self.timerLabel.setObjectName("currentTime_lbl")
        self.timerLabel.setText("00:00")

        # Reset Timer Button
        self.resettmr_btn = QtWidgets.QPushButton(self.win)
        self.resettmr_btn.setText("Reset Timer")
        self.resettmr_btn.setGeometry(QtCore.QRect(130, 160, 91, 31))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        self.resettmr_btn.setFont(font)
        self.resettmr_btn.setObjectName("resettmr_btn")
        self.resettmr_btn.clicked.connect(self.resetTimer)
        self.resettmr_btn.setEnabled(False)

        #Minimize button
        self.minimize_btn = QtWidgets.QPushButton(self.win)
        self.minimize_btn.setGeometry(QtCore.QRect(300, 0, 51, 23))
        self.minimize_btn.setObjectName("minimize_btn")
        self.minimize_btn.setText("Minimize")
        self.minimize_btn.clicked.connect(self.systemTrayMsg)

        self.retry_maintenance_btn = QtWidgets.QPushButton(self.win)
        self.retry_maintenance_btn.setGeometry(QtCore.QRect(280, 0, 21, 23))
        self.retry_maintenance_btn.setText("")
        self.retry_icon = iconFromBase64(refresh_icon)
        self.retry_maintenance_btn.setIcon(self.retry_icon)
        self.retry_maintenance_btn.setObjectName("retry_maintenance_btn")
        self.retry_maintenance_btn.clicked.connect(self.retryMAINTENANCEcheck)
        self.retry_maintenance_btn.hide()

        # Init QSystemTrayIcon
        self.tray_icon = QSystemTrayIcon(self)
        self.tray_icon.setIcon(self.icon)
        self.tray_icon.activated.connect(self.onTrayIconActivated)

        show_action = QAction("Show", self)
        hide_action = QAction("Hide", self)
        show_action.triggered.connect(self.show)
        hide_action.triggered.connect(self.systemTrayMsg)
        tray_menu = QMenu()
        tray_menu.addAction(show_action)
        tray_menu.addAction(hide_action)
        self.tray_icon.setContextMenu(tray_menu)
        self.tray_icon.show()

        # Show window
        self.win.show()

        if MAINTENANCE_TIMER_DURATION_INT != 0:
            self.backupTimer.timeout.connect(lambda: self.backupConfig("INFO", ""))
            self.backupTimer.start(30000)

        self.winEventTimer.timeout.connect(lambda: win32gui.PumpWaitingMessages())
        self.winEventTimer.start(1000)

        self.update_app_timer()
        self.update_maintenance_timer()

        self.ThreadingClass = ThreadingClass()
        self.ThreadingClass.start()
        self.ThreadingClass.maintenance_signal.connect(self.updateMAINTENANCEStatus_first_time)

    def backupConfig(self, msgType, log_message):
        yaml_dict = {"originalTimer": TIMER_DURATION_INT, "currentTimer": self.time_left_int,
                     "originalmaintenanceTimer": MAINTENANCE_TIMER_DURATION_INT, "currentmaintenanceTimer": self.maintenanceTimerInterval}
        with open("config.yaml", "w") as x:
            yaml.dump(yaml_dict, x)
        if log_message != "":
            if checkEventSource(event_log_name, event_log_source) == "True":
                addEvent(event_log_name, event_log_source, "113", log_message)
            else:
                createEventLog(event_log_name, event_log_source)
                addEvent(event_log_name, event_log_source, "113", log_message)
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[" + msgType + "] - " + log_message,
                  flush=True)
        else:
            print(datetime.datetime.now().astimezone().strftime(
                "%m-%d-%Y %H:%M:%S [%z]") + "[" + msgType + "] - Config backup has been executed.",
                  flush=True)

    def closeEvent(self, event):
        if self.time_left_int != 0:
            self.backupConfig("WARNING",
                              "An attempt to close the application has been executed. Storing config for backup...")
            self.systemTrayMsg()
            event.ignore()
        if self.maintenanceTimerInterval == 0:
            self.maintenanceTimerInterval = 1

    def show(self):
        self.win.show()

    def hide(self):
        self.win.hide()

    def systemTrayMsg(self):
        self.hide()
        self.tray_icon.showMessage(
            "LE Session Manager",
            "Application was minimized to tray. Running in background...",
            QSystemTrayIcon.Information,
            2000
        )

    def onTrayIconActivated(self, reason):
        if reason == QSystemTrayIcon.DoubleClick:
            self.show()

    def startAppTimer(self):
        if CONTINUE_TIMER:
            self.time_left_int = CURRENT_TIMER_DURATION_INT
        else:
            self.time_left_int = TIMER_DURATION_INT

        self.appTimer.timeout.connect(self.timerTimeout)
        self.appTimer.start(1000)

        self.maintenanceTimer.timeout.connect(self.maintenanceTimerTimeout)
        self.maintenanceTimer.start(1000)

    def startTimer_maintenance(self):
        self.maintenanceTimer.timeout.connect(self.maintenanceTimerTimeout)
        self.maintenanceTimer.start(1000)

    def timerTimeout(self):
        try:
            self.time_left_int -= 1

            if (self.time_left_int == 60) or (self.time_left_int == (TIMER_DURATION_INT / 2)) or (self.time_left_int == (TIMER_DURATION_INT / 4)):
                self.show()

                # in case timer suddenly stops
                self.pauseAppTimer()
                self.appTimer.disconnect()
                if not self.appTimer.isActive():
                    self.continueTimer()

                message_resettmr_box_widget = QWidget()
                message_resettmr_box = QMessageBox
                message_resettmr_box.setWindowIcon(message_resettmr_box_widget, self.icon)
                message_resettmr_box.setWindowFlag(message_resettmr_box_widget, QtCore.Qt.WindowStaysOnTopHint)
                popup = message_resettmr_box.warning(message_resettmr_box_widget, '',
                                             str(secs_to_minsec(self.time_left_int)) + " left. Do you want to reset the timer?",
                                             message_resettmr_box.Yes | message_resettmr_box.No)
                if popup == message_resettmr_box.Yes:
                    self.resetTimer()

            if self.time_left_int == 0:
                self.pauseSdtTimer()
                self.pauseAppTimer()
                logged_user = os.getenv('username')
                log_message = "User '" + str(logged_user) + "' has been logged off."
                print(
                    datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + log_message,
                    flush=True)
                if checkEventSource(event_log_name, event_log_source) == "True":
                    addEvent(event_log_name, event_log_source, "110", log_message)
                else:
                    createEventLog(event_log_name, event_log_source)
                    addEvent(event_log_name, event_log_source, "110", log_message)
                sys.stdout.close()
                try:
                    os.remove("config.yaml")
                except OSError as e:
                    print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[WARNING] - " + str(e), flush=True)
                os.system('cmd /c "shutdown /l /f"')
                sys.exit(app.exec_())

            self.update_app_timer()
        except Exception as e:
            var = traceback.format_exc()
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(var),
                  flush=True)
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(e),
                  flush=True)

    def maintenanceTimerTimeout(self):
        try:
            self.maintenanceTimerInterval -= 1

            if self.maintenanceTimerInterval == 0:
                self.pauseSdtTimer()
                self.ThreadingClass = ThreadingClass()
                self.ThreadingClass.start()
                self.ThreadingClass.maintenance_signal.connect(self.updateMAINTENANCEStatus)

            self.update_maintenance_timer()
        except Exception as e:
            var = traceback.format_exc()
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(var),
                  flush=True)
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(e),
                  flush=True)

    def pauseAppTimer(self):
        self.appTimer.stop()

    def pauseSdtTimer(self):
        self.maintenanceTimer.stop()

    def continueTimer(self):
        self.appTimer.timeout.connect(self.timerTimeout)
        self.appTimer.start(1000)

    def update_app_timer(self):
        minsec = secs_to_minsec(self.time_left_int)
        self.timerLabel.setText(minsec)
        self.tray_icon.setToolTip(minsec + " remaining")

    def update_maintenance_timer(self):
        minsec = secs_to_minsec(self.maintenanceTimerInterval)
        self.ttcStatus_lbl.setText("Time to check MAINTENANCE: " + minsec)

    def retryMAINTENANCEcheck(self):
        self.maintenanceStatus_lbl.setText("Retrying...")
        self.retry_maintenance_btn.hide()
        self.maintenanceTimerInterval = 1

    def resetTimer(self):
        try:
            self.time_left_int = TIMER_DURATION_INT
            log_message = "Reset timer initiated. Setting time back to " + str(secs_to_minsec(TIMER_DURATION_INT)) + " (minutes:seconds)"
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + log_message, flush=True)
            if checkEventSource(event_log_name, event_log_source) == "True":
                addEvent(event_log_name, event_log_source, "110", log_message)
            else:
                createEventLog(event_log_name, event_log_source)
                addEvent(event_log_name, event_log_source, "110", log_message)
        except Exception as e:
            var = traceback.format_exc()
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(var),
                  flush=True)
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(e),
                  flush=True)

    def updateMAINTENANCEStatus(self, value):
        self.pauseAppTimer()
        self.ttcStatus_lbl.setText("Checking MAINTENANCE status...")
        print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + "Checking MAINTENANCE status...", flush=True)

        try:
            if "True" in value:
                # Changing text and disabling the button
                self.maintenanceStatus_lbl.setText("MAINTENANCE status: Active (Logoff timer freeze)")
                self.resettmr_btn.setEnabled(False)

                # disconnects the thread to reset the interval count of the timers.
                self.maintenanceTimer.disconnect()

                if self.appTimer.isActive():
                    self.appTimer.disconnect()

                log_message = "MAINTENANCE status: True"
                print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + log_message, flush=True)

                # Initialize the main timer and the MAINTENANCE timer
                self.maintenanceTimerInterval = MAINTENANCE_TIMER_DURATION_INT
                self.startTimer_maintenance()
            elif "False" in value:
                # Changing text and enabling the button
                self.maintenanceStatus_lbl.setText("MAINTENANCE status: Inactive")
                self.resettmr_btn.setEnabled(True)

                # disconnects the thread to reset the interval count of the timers.
                self.maintenanceTimer.disconnect()
                self.appTimer.disconnect()

                log_message = "MAINTENANCE status: False"
                print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + log_message, flush=True)

                # Initialize the main timer and the MAINTENANCE timer
                self.maintenanceTimerInterval = MAINTENANCE_TIMER_DURATION_INT

                if not self.appTimer.isActive():
                    self.continueTimer()
                self.startTimer_maintenance()
            else:
                self.maintenanceStatus_lbl.setText("MAINTENANCE status: Unknown")
                self.resettmr_btn.setEnabled(False)

                # disconnects the thread to reset the interval count of the timers.
                self.maintenanceTimer.disconnect()

                if self.appTimer.isActive():
                    self.appTimer.disconnect()

                log_message = "MAINTENANCE status: Unknown"
                print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + log_message, flush=True)

                # Initialize the main timer and the MAINTENANCE timer
                self.maintenanceTimerInterval = MAINTENANCE_TIMER_DURATION_INT
                self.startTimer_maintenance()
                self.retry_maintenance_btn.show()

        except Exception as e:
            var = traceback.format_exc()
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(var), flush=True)
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(e), flush=True)
            if checkEventSource(event_log_name, event_log_source) == "True":
                addEvent(event_log_name, event_log_source, "113", str(e))
            else:
                createEventLog(event_log_name, event_log_source)
                addEvent(event_log_name, event_log_source, "113", str(e))

    def updateMAINTENANCEStatus_first_time(self, value):
        self.pauseAppTimer()
        print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + "Checking MAINTENANCE status...", flush=True)

        try:
            if MAINTENANCE_TIMER_DURATION_INT == 0:
                self.maintenanceStatus_lbl.setText("MAINTENANCE status: Checking disabled")
                self.resettmr_btn.setEnabled(True)
                self.pauseSdtTimer()
                self.continueTimer()
                log_message = "MAINTENANCE status: Checking disabled"
                print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + log_message,
                      flush=True)
            else:
                if "True" in value:
                    self.maintenanceStatus_lbl.setText("MAINTENANCE status: Active (Logoff timer freeze)")
                    self.resettmr_btn.setEnabled(False)
                    self.startTimer_maintenance()
                    log_message = "MAINTENANCE status: True"
                    print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + log_message, flush=True)
                elif "False" in value:
                    self.maintenanceStatus_lbl.setText("MAINTENANCE status: Inactive")
                    self.resettmr_btn.setEnabled(True)
                    self.startAppTimer()
                    log_message = "MAINTENANCE status: False"
                    print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + log_message, flush=True)
                else:
                    self.maintenanceStatus_lbl.setText("MAINTENANCE status: Unknown")
                    self.resettmr_btn.setEnabled(False)
                    self.startTimer_maintenance()
                    self.retry_maintenance_btn.show()
                    log_message = "MAINTENANCE status: Unknown"
                    print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + log_message, flush=True)
        except Exception as e:
            var = traceback.format_exc()
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(var), flush=True)
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(e), flush=True)
            if checkEventSource(event_log_name, event_log_source) == "True":
                addEvent(event_log_name, event_log_source, "113", str(e))
            else:
                createEventLog(event_log_name, event_log_source)
                addEvent(event_log_name, event_log_source, "113", str(e))


class ThreadingClass(QtCore.QThread):
    maintenance_signal = QtCore.pyqtSignal(str)

    def __init__(self):
        super(ThreadingClass, self).__init__()

    def run(self):
        try:
            if not os.path.exists("<product_config_dir>\\<product>.conf"):
                print(datetime.datetime.now().astimezone().strftime(
                    "%m-%d-%Y %H:%M:%S [%z]") + "[WARN] - " + "<product>.conf not found.", flush=True)
                self.maintenance_signal.emit("Unknown")
            else:
                for i in range(3):
                    value = subprocess.run(["C:\\Python3\\python.exe",
                                    "<company_scripts>\\<product>_manage_maintenance.py", "-maintenanceJob", "status"],
                                capture_output=True, shell=True, text=True).stdout

                    if i == 2:
                        self.maintenance_signal.emit("Unknown")
                        break
                    elif "True" in value or "False" in value:
                        self.maintenance_signal.emit(value)
                        break
                    else:
                        print(datetime.datetime.now().astimezone().strftime(
                            "%m-%d-%Y %H:%M:%S [%z]") + "[INFO] - " + "MAINTENANCE Status: " + value + " Retrying...", flush=True)
        except Exception as e:
            var = traceback.format_exc()
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(var), flush=True)
            print(datetime.datetime.now().astimezone().strftime("%m-%d-%Y %H:%M:%S [%z]") + "[ERROR] - " + str(e), flush=True)
            self.maintenance_signal.emit("Unknown")


if __name__ == "__main__":
    if args["help"]:
        app = QtWidgets.QApplication(sys.argv)
        w = QWidget()
        w.setWindowIcon(iconFromBase64(image_icon))
        w.setWindowTitle("LE Session Manager")
        w.setFixedSize(450, 250)

        sys.stdout = open("tmp.txt", "w")
        parser.print_help()
        sys.stdout.close()

        with open("tmp.txt") as f:
            lines = f.read()

        text = QPlainTextEdit()
        text.setReadOnly(True)
        text.appendPlainText(lines)

        os.remove("tmp.txt")

        btn_close = QtWidgets.QPushButton("Close")
        btn_close.resize(btn_close.minimumSizeHint())
        btn_close.clicked.connect(QtCore.QCoreApplication.instance().quit)

        l = QVBoxLayout()
        l.addWidget(text)
        l.addWidget(btn_close)
        w.setLayout(l)
        w.show()
        sys.exit(app.exec_())

    elif args["version"]:
        app = QtWidgets.QApplication(sys.argv)
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Information)
        msg.setText('Product Version: 1.4')
        msg.setWindowTitle("LE Session Manager")
        msg.setWindowIcon(iconFromBase64(image_icon))
        msg.show()
        sys.exit(app.exec_())

    lockfile = QtCore.QLockFile(QtCore.QDir.tempPath() + '/LE_Session_Manager.lock')
    if lockfile.tryLock(100):
        pre_start()
        app = QtWidgets.QApplication(sys.argv)
        QCoreApplication.setApplicationName('LE Session Manager')
        main_window = App()
        main_window.show()
        sys.exit(app.exec_())